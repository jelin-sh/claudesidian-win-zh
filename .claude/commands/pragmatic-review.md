---
name: pragmatic-review
description: '专注于 YAGNI 和 KISS 原则的交互式实用代码审查'
version: 1.0.0
argument-hint: '[--auto] [--ci] [--deep (6-pass)] [--branch branch-name] [--base base-branch]'
allowed-tools:
  [
    Read,
    Grep,
    Glob,
    Bash(test:*),
    Bash(git:*),
    Bash(echo:*),
    Bash(head:*),
    Bash(wc:*),
    Bash(tr:*),
  ]
---

# 实用代码审查:聚焦 YAGNI 与 KISS

你将执行一个专注于 **YAGNI**(You Aren't Gonna Need It,你不会需要它)和 **KISS**(Keep It Simple, Stupid,保持简单)原则的交互式代码审查。

## 审查模式

**默认模式**: 快速的 YAGNI/KISS 聚焦审查

- 扫描过度工程、未使用的抽象、不必要的复杂性
- 快速的安全和性能检查(OWASP 基础、明显的 N+1 查询)
- 自我反思以证据验证发现

**深度模式**(`--deep` 标志): 多轮综合审查

- 第1轮: 安全性(OWASP Top 10、输入验证、认证问题)
- 第2轮: 架构(SOLID 原则、关注点分离)
- 第3轮: 逻辑(边缘情况、错误处理、正确性)
- 第4轮: 性能(算法复杂度、资源泄漏)
- 第5轮: YAGNI/KISS(过度工程、不必要的抽象)
- 第6轮: 可维护性(可读性、测试、文档)
- 所有轮次后的自我反思

在以下情况使用 `--deep`:

- 安全关键变更(认证、支付、数据处理)
- 核心架构修改
- 有许多边缘情况的复杂逻辑变更
- 性能敏感代码路径

在以下情况使用默认模式:

- 功能添加
- Bug 修复
- 重构
- 文档变更

**CI 模式**(`--ci` 标志): 用于 GitHub Actions 的非交互模式

- 跳过所有交互式提示
- 自动选择:所有分支变更对比基础分支
- 如果可用,使用 `$GITHUB_BASE_REF` 环境变量
- 一次性输出所有发现结果为 markdown(摘要视图)

## 步骤 1: 确定审查范围

### 检查当前 Git 状态

首先,通过运行以下命令验证我们是否在 git 仓库中:

- `test -d .git` 检查 .git 目录是否存在

如果不在 git 仓库中,请用户手动指定要审查的文件。

如果在 git 仓库中,收集信息:

#### 当前分支:
运行: `git rev-parse --abbrev-ref HEAD`

#### 默认分支检测:
1. 尝试: `git rev-parse --verify main`
2. 如果失败,尝试: `git rev-parse --verify master`
3. 如果失败,尝试: `git rev-parse --verify develop`

如果用户在参数中指定了 `--base [branch]`,则改用该分支。

#### 工作目录状态:
运行: `git status --short | head -20`

### 向用户展示选项

**如果存在 `--ci` 标志**: 跳过所有交互式提示并自动选择
选项 2: 审查当前分支对比基础分支的所有变更。

除非存在 `--auto` 或 `--ci` 标志,否则询问用户:

```
📋 代码审查范围选择
════════════════════════════════

你想审查什么?

1️⃣  当前未提交的变更
2️⃣  当前分支的所有变更(对比[检测到的默认分支])
3️⃣  特定文件或目录
4️⃣  最近 N 次提交
5️⃣  仅暂存的变更

请输入你的选择(1-5):
```

## 步骤 2: YAGNI/KISS 分析框架

对于每个识别的文件,分析这些模式:

### YAGNI 检测模式

1. **未使用的抽象**
   - 只有一个实现的接口/协议
   - 只有一个具体子类的抽象基类
   - 总是相同的泛型类型

2. **过早的灵活性**
   - 从不改变的配置
   - 没有插件的插件系统
   - 总是开/关的功能开关

3. **过度工程指标**
   - 简单对象的工厂类
   - 2-3 个字段对象的构建器模式
   - 只有一个监听器的事件系统

4. **推测性代码**
   - "TODO: 可能需要这个"注释
   - "以防万一"注释掉的代码
   - 无法到达的代码路径
   - 从未被调用的方法

5. **GenericButton 反模式**
   - 有 8+ 个可选参数服务于不同用例的组件
   - 太多的 props,以至于使用它就像从头写一样复杂

6. **过早抽象 - 三法则**
   - 在第1次或第2次重复时创建抽象(等待第3次!)
   - 参考:Martin Fowler - "容忍两次重复,在第3次时重构"

### KISS 违反模式

1. **冗长的实现**
   - 可以减少 >50% 的行数
   - 重新实现标准库函数
   - 简单字符串操作可用时的复杂正则表达式

2. **抽象成瘾**
   - 超过 3 层继承/包装
   - 每层之间的接口

3. **聪明代码**
   - 需要大量注释来解释
   - 不必要地使用晦涩的语言特性
   - 应该是 5 行清晰代码的单行代码

4. **捕获-日志-退出 反模式**
   - 捕获异常只是为了记录和退出
   - 用关于出了什么问题的猜测替换实际错误

   ```typescript
   // 糟糕:用猜测替换实际错误
   try {
     await createNewBranch({ branchName, cwd })
   } catch (error) {
     console.error('Error: Not in a git repository') // 可能是错的!
     process.exit(1)
   }

   // 正确:让它自然抛出
   await createNewBranch({ branchName, cwd })
   ```

### 要检查的安全模式

即使在 YAGNI/KISS 审查中,也要标记关键安全问题:

1. **SQL 注入**
   - SQL 查询中的字符串拼接
   - 缺少参数化查询

2. **认证/授权**
   - 硬编码的密钥
   - 弱默认值: `SECRET = os.getenv('KEY', 'default')`
   - 没有过期的 JWT

3. **未验证的外部输入**
   - 直接使用未经验证的 URL 参数
   - 在没有模式验证的情况下信任 API 响应数据

### 要检查的性能模式

标记明显的性能问题:

1. **N+1 查询问题**
   - 进行数据库调用的循环
   - 缺少预加载

2. **低效算法**
   - 本可以用 O(n) 或 O(n log n) 的 O(n²)
   - 不必要的嵌套循环

## 步骤 3: 执行分析

**检查 `--deep` 标志**: 如果存在,使用多轮深度模式,进行 6 轮顺序审查。否则,使用快速 YAGNI/KISS 模式。

**重要**: 只分析在此审查范围内实际变更的代码。
不要标记已存在的问题。

## 步骤 3.5: 自我审查轮

**在展示发现之前,验证每个问题:**

1. **证据检查:**
   - 我能提供支持此批评的链接/参考吗?
   - 我解释了为什么这很重要吗?

2. **严重性验证:**
   - 此评级准确吗(高/中/低)?
   - 此问题真的会导致问题吗?

3. **YAGNI 特定检查:**
   - 如果标记重复:这是第3次+出现吗?
   - 这可以稍后当我们有更多信息时重构吗?

**移除或降级任何未通过这些检查的问题。**

## 步骤 4: 交互式审查流程

### 问题严重性前缀

使用这些前缀传达优先级:

| 前缀 | 含义 | 所需操作 |
| ------------- | ---------------------------------- | --------------------- |
| `issue:` | Bug、正确性问题 | 合并前必须修复 |
| `nit:` | 小改进、风格 | 可选、不阻塞 |
| `thought:` | 设计考虑 | 讨论、可延期 |
| `suggestion:` | 带代码的具体改进 | 认真考虑 |

### 交互式演练

对于每个问题,展示:

```
═══════════════════════════════════════
问题 [当前] / [总计]
═══════════════════════════════════════

📁 文件: [文件名]
📍 行: [起始-结束]
🏷️  类型: [YAGNI | KISS | 两者]
🎯 严重性: [高 | 中 | 低]

当前代码:
[显示实际代码片段]

检测到的问题: [具体描述]

为什么重要: [解释实际成本/问题]

建议的简化:
[显示更简单的替代代码]

═══════════════════════════════════════

你想做什么?
1. ✅ 接受 - 添加到修复列表
2. ❌ 跳过 - 保留当前代码
3. 💬 讨论 - 标记以供团队审查
4. 👀 上下文 - 查看更多周围代码
5. ⏹️  停止 - 在此结束审查
```

## 步骤 5: 核心审查规则

### 始终标记这些 YAGNI 问题:

1. **只有单一实现的接口**
2. **未使用的代码** - 零调用者的函数/方法
3. **推测性数据库字段** - 始终为 NULL 的列
4. **过早优化** - 测量之前的缓存

### 始终标记这些 KISS 违反:

1. **标准库重新实现**
2. **过度抽象层**
3. **配置大于约定** - 50 行代码有 100 行配置

### 不要标记这些:

1. **必要的复杂性** - 错误处理、安全措施
2. **领域复杂性** - 确实复杂的业务规则
3. **团队约定** - 商定的模式

## 步骤 6: 最终摘要

```
📝 实用审查完成
═══════════════════════════════

审查统计:
• 已审查文件: [X]
• 变更行数: [Y]

发现问题: [Y 总计]
• 关键(阻塞): [数量]
• 高优先级: [数量]
• 中: [数量]
• 低: [数量]

复杂性降低潜力:
• 可删除行数: ~[总计] (-X%)
• 不必要的抽象: [数量]

前 3 个快速胜利:
1. [最大影响、最容易的更改]
2. [第二大影响]
3. [第三大影响]

建议: [明确的发布/不发布及理由]

═══════════════════════════════
```

## 命令参数参考

- `--auto` : 跳过交互式提示,使用默认值(未提交的变更)
- `--ci` : CI 模式 - 跳过所有提示,审查分支对比基础
- `--deep` : 启用 6 轮综合审查
- `--branch [name]` : 审查特定分支
- `--base [branch]` : 对比此基础分支

示例:

- `/pragmatic-review` - 交互模式
- `/pragmatic-review --auto` - 自动审查当前变更
- `/pragmatic-review --ci` - GitHub Actions 的 CI 模式
- `/pragmatic-review --deep` - 综合 6 轮审查

## 核心理念

如有疑问,请记住:

1. **YAGNI**: 功能成本是 4 倍:构建时间、维护成本、修复成本、机会成本
2. **KISS**: 调试比编写难两倍 - 如果你编写了最聪明的代码,你就不够聪明来调试它
3. **三法则**: 容忍两次重复,在第3次时重构
4. **实用**: 今天发布可工作的软件,明天完善它

你的角色是简单性的捍卫者。每一行被删除的代码都是胜利。

## 参考资料

- Martin Fowler - YAGNI: https://martinfowler.com/bliki/Yagni.html
- KISS 原则: https://en.wikipedia.org/wiki/KISS_principle
- OWASP Top 10: https://owasp.org/www-project-top-ten/
- Addy Osmani - "避免大型 Pull Request"
- Jeff Atwood - "Curly 定律:做一件事"
